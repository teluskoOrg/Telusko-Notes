---
title: Type Conversion and Casting
---
<Video id="CPk8pffKV64" />


Type conversion is the process of converting one data type into another.  
This is a very important concept in Java, especially when dealing with arithmetic operations, mixed data types, and memory optimization.

Java provides two major forms of type conversion:

1. **Widening (Implicit Conversion)** – When a smaller data type is automatically converted into a larger one.  
2. **Narrowing (Explicit Casting)** – When a larger data type is manually converted into a smaller one.

Understanding both is essential for writing safe and predictable Java programs.

## What is Type Conversion?

Type conversion happens whenever a variable of one type is assigned to another type.  
Java decides whether the conversion is safe and automatic (widening), or unsafe and must be done manually (narrowing).

### Two Categories of Type Conversion

1. **Widening (Implicit Conversion)**  
   - Automatically performed by Java  
   - Safe: no data loss  
   - Happens from smaller to larger types  

2. **Narrowing (Explicit Casting)**  
   - Must be done manually by the programmer  
   - Risky: may cause data loss  
   - Happens from larger to smaller types


## Example 1 – Implicit Conversion (Widening)

When a smaller type is stored in a larger type, Java handles it automatically.

```java
public class Hello {
    public static void main(String[] args) {
        byte b = 127;
        int a = b;     // Implicit conversion (byte → int)
        System.out.println(a);   // 127
    }
}
```

**Why it works:**
`int` has a larger memory size than `byte`, so Java safely expands the value.

## Example 2 – Narrowing (Explicit Casting)

Narrowing requires a **cast operator**, because you're forcing a large value into a smaller container.

```java
public class Hello {
    public static void main(String[] args) {
        int a = 256;
        byte b = (byte) a;   // Explicit casting
        System.out.println(b);  // Output: 0 (data loss)
    }
}
```

**Why data loss occurs:**

* `byte` can store only values from -128 to 127
* `256` exceeds that range
* The value “wraps around” due to overflow

## Example 3 – Float to Int

Decimal values cannot be stored directly in integer variables.
The decimal part gets removed during narrowing.

```java
float f = 5.6f;
int x = (int) f;   // Explicit casting
System.out.println(x);  // 5 (decimal lost)
```

**Note:** Casting a float to int does **not** round — it truncates.

## Invalid Example

You cannot assign a decimal value directly to an integer variable:

```java
int i = 5.7;  //  Error → cannot assign decimal to int directly
```

This fails because Java does not automatically convert a floating-point literal to an integer.


## Type Promotion

Java promotes smaller types to larger types during expressions to avoid overflow.

Example:

```java
byte a = 10;
byte b = 20;
// a + b → promoted to int
int result = a + b;
System.out.println(result);  // 30
```

**Why promoted to int?**
All arithmetic operations involving `byte`, `short`, and `char` are automatically converted to **int** before evaluation.


## Direct Execution of `.java` (Java 11+)

Starting from **Java 11**, you can run Java programs without a separate compile step.

```bash
java Hello.java
```

Java internally performs:

1. Compilation → creates bytecode
2. Immediate execution → runs the program

This makes testing small programs faster and easier.


## Summary

* **Widening (Implicit Conversion):**
  `byte → short → int → long → float → double`

* **Narrowing (Explicit Casting):**
  `double → float → long → int → short → byte`

* Widening is **automatic** and **safe**.

* Narrowing is **manual** and may lead to **data loss**.

* Java automatically promotes smaller types to `int` in arithmetic expressions.

* Java 11 introduced the ability to run `.java` files directly.